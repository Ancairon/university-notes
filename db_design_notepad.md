# Προτεινόμενο Βιβλίο

- Θεμελειώδεις Aρχές Bάσεων Δεδομένων Elmasri & s.b. Navathe 7η εκδοση Εκδοσεις Διαυλος

Γενικά ένα database { Database -> Tablespace -> Segment -> Extent -> Block (-> περιέχει)

Page:
| Block | Block | Block |

## Λογική οργάνωση

- **Extent** είναι ένα σύνολο απο συνεχόμενα blocks
- **Segment** είναι ένα σύνολο από extnet που αντιστοιχούν σε μια λογική οντότητα.

### Δομή του block

> Το block είναι η μικροότερη μονάδα Ι/Ο της βδ

**Κάθε block έχει:**

- Header : σε τι segment βρίσκεται το block
- Table dir : ποιος πίνακας έχει εγγραφές στο block
- Row dir : οι δ/σεις των εγγραφών στο block
- Row data : οι εγγγραφές

> Μας ενδιαφέρει να ξέρουμε πόσα μπλοκ θέλουμε να φέρουμε από την μνήμη, όσο το λιγότερο τόσο το καλύτερο (query optimization) <- πολυπλοκότητα

## Πόσες εγγραφές χωράνε σε ένα block

1024/100=10 εγγραφες με στρογγυλοποιηση

Αρχειο 10^5 block 100.000/10

> Με τον εναπομείνοντα χώρο, μπορώ να το κάνω span και απλά να χρησιμοποιήσω τον ελεύθερο χώρο από δύο spans στο τέλος γεμάτων block.

## Εκτεινόμενη (span)

10^5 εγγραφες * 100bytes η κάθε μια = 10^7bytes

10^7/1024 = 9990 blocks

## Μη εκτεινόμενη

1024/100 = 10 εγγραφες σε κάθε block

10^5/10 10000 blocks

Βασικές πράξεις

- **Open**: το αρχείο, δεσμεύει ενδιάμεση μνήμη, ανακτά την επικεφαλίδα του αρχέιου, βάζει τον δείκτη στην αρχή του
  αρχείου

- **Reset**: τον pointer στην αρχή του αρχείου

- **Find/locate**:

- **Read/get**

- **Delete**

- **Modify**

- **Insert**

- **Close**

    - Άλλες πράξεις

        - Scan

        - Find all

        - Find n

        - Find ordered

        - Reorganize

Η οργάνωση των αρχείων είναι στενά συνδεδεμένη με τις πράξεις που αναμένουμε ότι θα γίνονται συχνά

> Αν σαρώσω για id=10 πχ μπορώ να το βρω και να σταματήσω στο πρώτο block, κάπου στην μέση, ή στο τέλος, δηλαδή Ν, άρα πολυπλοκότητα O(N/2).\
> Αν σαρώνω για salary =100, τότε θα πρέπει να περάσω από όλα, γιατί δεν είναι μοναδική τιμή. Άρα Ο(Ν).

## Αρχεία Διατεταγμένων εγγραφών ½

- Πεδίο διάταξης: οι τιμες των εγγραφών στο πεδίο αυτό καθορίζουν τη διάταξή τους στο αρχείο

- Κλειδί διαάταξης: το πεδίο διάταξης είναι το πεδίο κλειδί

- Αποτελεσματική ανάγνωση εγγραφών με διάταξη των τιμών του πεδίου διάταξης

- Αποτελεσματική ανάγνωση επίμενης εγγραφής στο πείο διάταξης: είναι το ίδιο (ή το επόμενο block)

- Αποτελεσματική αναζήτηση στην τιμή του κλειδιού διάταξης" -> δυαδική αναζήτηση

### Δυαδική αναζήτηση

Block | Θέλω αυτό το block | Block

Ανακτώ ή το αριστερά ή το δεξιά

Στην πρώτη αναήτηση απορρίπτω τα μισά, στην επόμενη πάλι το ιδιο κλπ

Άρα αν είχα 1024 block, τότε θα είναι Log2(1024)=10

Κόστος αναζήτησης log2 N+μ (μ είναι το επόμενο πχ από αυτό που ψάχνω αμα έχω μισθούς 1000 και βρώ έναν τότε παίζει να
είναι και ο επόμενος σε μια ταξινομημένη βάση)

# 19/10/21

## Ευρετήρια

> Ευρετήρια χτίζονται πάνω στα αρχεία Σωρού ή Ταξινομημένα.

Το ευρετήριο (index) περιέχει την τιμή μόνο ενός πεδίου, του πεδίου ευρετηρίασης και έναν δείκτη στο block αρχείου που
περιέχει την πλήρη εγγραφή

```
struct {
int indexing_field
int*  p
}
```

Σε ένα block, μπορώ να έχω πολλές εγγραφές ευρετηρίων, από το να έχω τα raw αρχεία επειδή οι εγγραφές ευρετηρίων είναι
σχετικά μικρού μεγέθους.

Τα ευρετήρια:

- daitetagmenew timew

- κάνουν dyadikh anazhthsh

- κάνουν σεριακη αναζητηση στο μπλοκ του αρχειου

- Πυκνό ευρετήριο: Μια εγγραφή ευρετηρίου για κάθε εγγραφή του αρχείου

> Μπορεί πχ να έχω ένα αρχείο σωρού, που να έχει και διπλότυπα, άρα έχω ένα πυκνό ευρετήριο για αυτό.
>
> - Δευτερέυον ευρετήριο.

- Αραιό Ευρετήριο

> Σε ταξινομημένο ή(και) σε πεδίο κλειδί

### Αραιό Πρωτεύον ευρετήριο

- πριμαρυ ινδεχ
- Το ευρετήριο έχει την πρώτη εγγραφή κάθε block, σαν λεξικό.

> Άρα σε ένα page 250.000 block με 1εκ εγγραφες αρχείων, θα έχω 250.000 εγγραφές στο ευρετήριο.
> Αν πχ κάθε εγγραφή ευρετηρίου ήταν 20b και το κάθε block χωράει 1024 τότε
> Άρα σε ένα block χωράει 1024/20 =~ 50
> 250.000/50 = 5000 (πάντα στρογγυλοποιώ προς τα πάνω)
>
> > Άρα κόστος: log2(5000)<sub>13 block</sub>+ 1<sub>το block αρχείου</sub> = 10<sup>6</sup><sub>1εκ εγγραφές</sub>

Γενικά μπορώ να βάλω και μπλοκ (ή αρχείο) υπερχείλισης (δηλαδή θα κάνω συν όχι ένα, αλλά όσα block πρέπει να διαβάσω.)

### Ευρετήριο Συστάδων ταξινομημένα στα διπλότυπα

Γιαννης 1 Γιωργος 1 Κωστας 2 Μαρία 2

Εδώ ο γιάννης τελειώνει στο πρώτο block, ο γιώργος μπορεί να έχει εγγραφές και στο 2ο block, ο κώστας τελειώνει στο 2ο
γιατι μετά είναι η Μαρία.

- Παράδειγμα Συστάδων

1 εκ εγγραφες -> 5000 διαφορετικα ονοματα 250.000 block αρχειου Rindex = 50 bytes (μεγαλύτερη εγγραφή)

bindex με μη εκτεταμένες ολόκληρες εγγραφές 1024/50

bindex με εκτεταμενες καταχωρησεις 5000*50/1024

10^6 εγγραφες / 5000 ονοματα = 200 εγγραφες αρχειου ανα ονομα

200/4 εγγραφες σε καθε μπλοκ = 50 block

> log2(250)<sub>~8 block</sub>+ 50

Πυκνό ευρετήριο σε οποιοδηποτε πεδιο

bindex = 10^6/20 = 50.000 block ευρετηριου Rindex = 50 bytes b index = 10^6/(1024/50)
250.000 block αρχειου κοστος = λογ2(50.000) <sub>αναζητηση στο πυκνο ευρετηριο</sub> + {απο 1 εως 250.000} ==+παράδειγμα
eclass σελ 21==

==+Β και Β+ δέντρα==

ψάχνω τι ει:
B TREE INDEX 
HASH
INVERTED INDEX
BITMAP INDEX