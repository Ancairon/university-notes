# Προτεινόμενο Βιβλίο

- Θεμελειώδεις Aρχές Bάσεων Δεδομένων Elmasri & s.b. Navathe 7η εκδοση Εκδοσεις Διαυλος

Γενικά ένα database { Database -> Tablespace -> Segment -> Extent -> Block (-> περιέχει)

Page:
| Block | Block | Block |

## Λογική οργάνωση

- **Extent** είναι ένα σύνολο απο συνεχόμενα blocks
- **Segment** είναι ένα σύνολο από extent που αντιστοιχούν σε μια λογική οντότητα.

### Δομή του block

> Το block είναι η μικροότερη μονάδα Ι/Ο της βδ

**Κάθε block έχει:**

- Header : σε τι segment βρίσκεται το block
- Table dir : ποιος πίνακας έχει εγγραφές στο block
- Row dir : οι δ/σεις των εγγραφών στο block
- Row data : οι εγγγραφές

> Μας ενδιαφέρει να ξέρουμε πόσα μπλοκ θέλουμε να φέρουμε από την μνήμη, όσο το λιγότερο τόσο το καλύτερο (query optimization) <- πολυπλοκότητα

## Πόσες εγγραφές χωράνε σε ένα block

1024/100=10 εγγραφες με στρογγυλοποιηση

Αρχειο 10^5 block 100.000/10

> Με τον εναπομείνοντα χώρο, μπορώ να το κάνω span και απλά να χρησιμοποιήσω τον ελεύθερο χώρο από δύο spans στο τέλος γεμάτων block.

## Εκτεινόμενη (span)

10^5 εγγραφες * 100bytes η κάθε μια = 10^7bytes

10^7/1024 = 9990 blocks

## Μη εκτεινόμενη

1024/100 = 10 εγγραφες σε κάθε block

10^5/10 10000 blocks

Βασικές πράξεις

- **Open**: το αρχείο, δεσμεύει ενδιάμεση μνήμη, ανακτά την επικεφαλίδα του αρχέιου, βάζει τον δείκτη στην αρχή του
  αρχείου

- **Reset**: τον pointer στην αρχή του αρχείου

- **Find/locate**:

- **Read/get**

- **Delete**

- **Modify**

- **Insert**

- **Close**

Άλλες πράξεις

   - Scan

  - Find all

  - Find n

  - Find ordered

  - Reorganize

Η οργάνωση των αρχείων είναι στενά συνδεδεμένη με τις πράξεις που αναμένουμε ότι θα γίνονται συχνά

> Αν σαρώσω για id=10 πχ μπορώ να το βρω και να σταματήσω στο πρώτο block, κάπου στην μέση, ή στο τέλος, δηλαδή Ν, άρα πολυπλοκότητα O(N/2).\
> Αν σαρώνω για salary =100, τότε θα πρέπει να περάσω από όλα, γιατί δεν είναι μοναδική τιμή. Άρα Ο(Ν).

## Αρχεία Διατεταγμένων εγγραφών ½

- Πεδίο διάταξης: οι τιμες των εγγραφών στο πεδίο αυτό καθορίζουν τη διάταξή τους στο αρχείο

- Κλειδί διαάταξης: το πεδίο διάταξης είναι το πεδίο κλειδί

- Αποτελεσματική ανάγνωση εγγραφών με διάταξη των τιμών του πεδίου διάταξης

- Αποτελεσματική ανάγνωση επίμενης εγγραφής στο πείο διάταξης: είναι το ίδιο (ή το επόμενο block)

- Αποτελεσματική αναζήτηση στην τιμή του κλειδιού διάταξης" -> δυαδική αναζήτηση

### Δυαδική αναζήτηση

Block | Θέλω αυτό το block | Block

Ανακτώ ή το αριστερά ή το δεξιά

Στην πρώτη αναήτηση απορρίπτω τα μισά, στην επόμενη πάλι το ιδιο κλπ

Άρα αν είχα 1024 block, τότε θα είναι Log2(1024)=10

Κόστος αναζήτησης log2 N+μ (μ είναι το επόμενο πχ από αυτό που ψάχνω αμα έχω μισθούς 1000 και βρώ έναν τότε παίζει να
είναι και ο επόμενος σε μια ταξινομημένη βάση)

# 19/10/21

## Ευρετήρια

> Ευρετήρια χτίζονται πάνω στα αρχεία Σωρού ή Ταξινομημένα.

Το ευρετήριο (index) περιέχει την τιμή μόνο ενός πεδίου, του πεδίου ευρετηρίασης και έναν δείκτη στο block αρχείου που
περιέχει την πλήρη εγγραφή

```
struct {
int indexing_field;
int*  p;
}
```

Σε ένα block, μπορώ να έχω πολλές εγγραφές ευρετηρίων, από το να έχω τα raw αρχεία επειδή οι εγγραφές ευρετηρίων είναι
σχετικά μικρού μεγέθους.

Τα ευρετήρια:

- εχουν διατετεγμένες τιμές

- κάνουν διαδική αναζήτηση

- κάνουν σεριακη αναζητηση στο μπλοκ του αρχειου

- Πυκνό ευρετήριο: Μια εγγραφή ευρετηρίου για κάθε εγγραφή του αρχείου

> Μπορεί πχ να έχω ένα αρχείο σωρού, που να έχει και διπλότυπα, άρα έχω ένα πυκνό ευρετήριο για αυτό.
>
> - Δευτερέυον ευρετήριο.

- Αραιό Ευρετήριο

> Σε ταξινομημένο ή(και) σε πεδίο κλειδί

### Αραιό Πρωτεύον ευρετήριο

- primary index
- Το ευρετήριο έχει την πρώτη εγγραφή κάθε block, σαν λεξικό.

> Άρα σε ένα page 250.000 block με 1εκ εγγραφες αρχείων, θα έχω 250.000 εγγραφές στο ευρετήριο.
> Αν πχ κάθε εγγραφή ευρετηρίου ήταν 20b και το κάθε block χωράει 1024 τότε
> Άρα σε ένα block χωράει 1024/20 =~ 50
> 250.000/50 = 5000 (πάντα στρογγυλοποιώ προς τα πάνω)
>
> > Άρα κόστος: log2(5000)<sub>13 block</sub>+ 1<sub>το block αρχείου</sub> = 10<sup>6</sup><sub>1εκ εγγραφές</sub>

Γενικά μπορώ να βάλω και μπλοκ (ή αρχείο) υπερχείλισης (δηλαδή θα κάνω συν όχι ένα, αλλά όσα block πρέπει να διαβάσω.)

### Ευρετήριο Συστάδων ταξινομημένα στα διπλότυπα

Γιαννης 1 Γιωργος 1 Κωστας 2 Μαρία 2

Εδώ ο γιάννης τελειώνει στο πρώτο block, ο γιώργος μπορεί να έχει εγγραφές και στο 2ο block, ο κώστας τελειώνει στο 2ο
γιατι μετά είναι η Μαρία.

- Παράδειγμα Συστάδων

1 εκ εγγραφες -> 5000 διαφορετικα ονοματα 250.000 block αρχειου Rindex = 50 bytes (μεγαλύτερη εγγραφή)

bindex με μη εκτεταμένες ολόκληρες εγγραφές 1024/50

bindex με εκτεταμενες καταχωρησεις 5000*50/1024

10^6 εγγραφες / 5000 ονοματα = 200 εγγραφες αρχειου ανα ονομα

200/4 εγγραφες σε καθε μπλοκ = 50 block

> log2(250)<sub>~8 block</sub>+ 50

Πυκνό ευρετήριο σε οποιοδηποτε πεδιο

bindex = 10^6/20 = 50.000 block ευρετηριου Rindex = 50 bytes b index = 10^6/(1024/50)
250.000 block αρχειου κοστος = λογ2(50.000) <sub>αναζητηση στο πυκνο ευρετηριο</sub> + {απο 1 εως 250.000} ==+παράδειγμα
eclass σελ 21==

==+Β και Β+ δέντρα==

ψάχνω τι ειναι:
B TREE INDEX 
HASH
INVERTED INDEX
BITMAP INDEX



## 26/10/21

Oracle DATE,TIME,STRING functions για εργασία

Κόστη στις πράξεις:

1. WHERE = 
2. WHERE ><
3. JOIN
4. ORDER BY / GROUP BY

Γενικά μας συμφέρει να βάζουμε τα `σ`*(επιλογές)* πιο κοντά στους πίνακες ώστε να χειρίζομαι όσο το δυνατόν λιγότερα blocks.



#### Παράδειγμα

1 εκ εγγραφές | R=10^6
Κάθε μπλοκ χωράει 100 εγγραφές αρχείων | bfr = 100 εγγραφες/μπλοκ

1. Πόσα μπλοκ χωράει το αρχείο 
B=R/bfr=10^6/100=10.000 block


2. Πυκνό Ευρετήριο στο Α
bfr(i) = 1000 εγγραφές ευρετηρίου/μπλοκ
B(index)=R(index)/bfr(index)=10^6/1000=1000block
Κόστος είναι 10^6

3. Πυκνό ευρετήριο 1 επιπέδου
κόστος αναζήτησης log2(1000)=~10

4. E(Α<Κ)(R) A<K πρέπει να ψάξω σττο 20% του ευρετηρίου 200 block index
Kόστος(Α<Κ ευρετήριο) = 20+200 block
Χειρότερη -> Κόστος αρχείο  = ολο το αρχείο για να βρω 200000 εγγραφές
Καλύτερη -> 20% του 10000 = 2000

==+Διαφάνεια 22==
R<sub>κ</sub>=40 bytes R<sub>N</sub>=50bytes
bfr<sub>κ</sub>=100tuple/blocks bfr<sub>Ν</sub> = 80
b<sub>κ</sub>= 1000 blocks b<sub>Ν</sub>=500
r<sub>κ</sub> = 100.000tuples r<sub>Ν</sub> = 40.000



Συνένωση εμφωλευμένων βρογχων 
ουσιαστικά θα διαβάσω 1000 φορες τα 500 μπλοκ των ναυτικων b<sub>k</sub>*b<sub>Ν</sub>+b<sub>k</sub>



## 9/11/21
Plans, Cost, Indexes

```
CREATE TABLE THEORDERS AS SELECT * FROM XSALES.ORDERS;

CREATE TABLE THECUSTOMERS AS SELECT * FROM XSALES.CUSTOMERS;


DELETE FROM PLAN_TABLE;



EXPLAIN PLAN FOR 
SELECT ID,NAME,CREDIT_LIMIT 
FROM THECUSTOMERS
WHERE MARITAL_STATUS = 'single' AND GENDER = 'Female' AND CREDIT_LIMIT>10000;

SELECT COUNT(*) FROM THEORDERS;

SELECT * FROM PLAN_TABLE
START WITH ID=0
CONNECT BY PRIOR ID= PARENT_ID;

CREATE INDEX cope_index 
   ON THECUSTOMERS (id,name,credit_limit,marital_status,gender);
   ```

